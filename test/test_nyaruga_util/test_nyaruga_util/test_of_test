#include <type_traits>
#include <utility>
#include <functional>
#include <vector>
#include <iostream>


//関数の引数の型を得る
//template<typename Func>
//struct get_function_argument_num {
//};


//通常関数用
//template<typename Ret, typename... Args>
//struct get_function_argument_num
//{
 //   static const std::size_t value = sizeof...(Args);
//};

//template<typename Ret, typename... Args>
//std::size_t get_function_argument_num_v = get_function_argument_num<Ret,Args ...>::value;


		template<size_t current_pos, size_t target_pos, typename Head, typename ... Pack>
		constexpr decltype(auto) pac_select_pos_obj_impl(Head && head, Pack && ... pack) noexcept
		{
			if constexpr (current_pos == target_pos)
				return head;
			else if constexpr (current_pos < target_pos)
				return pac_select_pos_obj_impl<current_pos + 1, target_pos>(std::forward<Pack>(pack)...);
		}



	// pac select pos expansion
	// パラメーターパックの任意の位置のオブジェクトを返す関数
	template<size_t pos, typename ... Pack>
	constexpr decltype(auto) pac_select_pos_obj(Pack && ... pack) noexcept
	{
		return pac_select_pos_obj_impl<1, pos>(std::forward<Pack>(pack)...);
}

template<std::size_t sentinel, std::size_t count, typename R, 
typename F, typename Itr>
decltype(auto) runtime_unpack_impl(F&& f, Itr && current_itr, Itr && end_itr)
{
    if(current_itr == end_itr)
        return std::make_pair(false, [f = std::forward<F>(f)](auto && ... args){return f(std::forward<decltype(args)>(args)...);});

    if constexpr(sentinel >= count)
    {
        return runtime_unpack_impl<sentinel, count+1, R>(
        [car = *current_itr++, f = std::forward<F>(f)](auto&& ... args)
        {
            return f(car, std::forward<decltype(args)>(args)...);
        }, std::forward<Itr>(current_itr), std::forward<Itr>(end_itr));   
    }
    else
    {
        std::cout << u8"引数が多すぎます。 " << sentinel << u8"個までの引数にしてください。\n";
        return [f = std::forward<F>(f)](auto && ... args){return f(std::forward<decltype(args)>(args)...);};
    }
}

template<std::size_t sentinel, typename F, typename Container>
decltype(auto) runtime_unpack(F&& f, const Container& v) 
{
    while (pair.first != true)
    {
        pair = runtime_unpack_impl<sentinel, 1, decltype(f(*std::begin(v)))>
        (std::forward<F>(f), std::begin(v), std::end(v));
        
        if(pair.first == true) return pair.second;
    }
}

int main()
{
    std::vector<int> v{10, 20, 30};

    const auto lambda = [](auto && ... args)
    {
        return (0 + ... + std::forward<decltype(args)>(args));
    };

    std::cout << runtime_unpack<1>(lambda, v)();
}
